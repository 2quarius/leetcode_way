# My Answer
```c++
class Solution {
public:
    int minSwap(vector<int>& A, vector<int>& B) {
        int n = A.size();
        vector<vector<int> > dp(2,vector<int>(n,INT_MAX));
        dp[0][0] = 0;//A[0]与B[0]不交换的代价
        dp[1][0] = 1;//A[0]与B[0]交换的代价
        for(int i = 1; i < n; i++) {
            if(A[i] > A[i-1] && B[i] > B[i-1]) {
                // A[0..i],B[0..i]严格递增
                dp[0][i] = min(dp[0][i],dp[0][i-1]);//A[i]与B[i]不交换的代价
                dp[1][i] = min(dp[1][i],dp[1][i-1]+1);//A[i]与B[i]交换的代价
            }
            if(A[i] > B[i-1] && B[i] > A[i-1]) {
                // 必须交换A[i]、B[i]或者A[i-1]、B[i-1]
                dp[0][i] = min(dp[0][i],dp[1][i-1]); // 交换A[i-1]、B[i-1]
                dp[1][i] = min(dp[1][i],dp[0][i-1]+1);// 交换A[i]、B[i]
            }
        }
        return min(dp[0][n-1],dp[1][n-1]);
    }
};
```
# Explanation
解题思路：
其实这道题并没有想象中那么难，只是因为题目对的描述有一些地方不到位，导致在求解过程中不能正确理解题意，做不出来。

题目说到，我们*只可以交换两个数组同一个索引位置i*，最终要使得两个数组都呈现递增，随后题目说到假设输入总是有效的

这句话的意思是说，题目的输入总是至少存在一种方法可以使两个数组变成递增数组，不存在如下的数组：
```
A :  4 3
B :  1 2
```
上述的输入无论怎么样尝试，按照题目的方法是没办法将其转化成一个两个递增数组的，既然题目说了输入都是有效的那必然是不存在上面的输入的。
```
A: a1,a2,a3,a4...an
B: b1.b2.b3,b4...bn
```
其实我们可以根据上面的描述知道，对于任意一个位置i，必然有A[i] > A[i-1] || A[i] > B[i-1]

可以简单证明一下 如果i位置有A[i] <= A[i-1] && A[i] <= B[i-1]由于我们只能在同一个索引两个数组对应位置进行交换，那么可以看出A[i] <= A[i-1] && A[i] <= B[i-1]时，无论怎么换在i位置都不能满足 形成递增数组的要求，所以我们之前的假设成立。同理上面的公式对于B也成立，即B[i] > B[i-1] || B[i] > A[i-1]。

组合A,B的情况，合乎题意的无外乎两种 1. A[i] > A[i-1] && B[i] > B[i-1] 2. B[i] > A[i-1] && A[i] > B[i-1]

对于A[i] > A[i-1] && B[i] > A[i-1] 和 A[i] > B[i-1] && B[i] > B[i-1]  都是一个问题 
拿第一个举例，对于B[i-1]的情况我们无从知晓，这就导致了，没法确定一定在交换后可以形成递增序列，而题目又说输入一定是有效的那无外乎A[i]>A[i-1]>B[i-1] 或者 A[i] > B[i-1] > A[i-1] 而这又退化成了我们列举的两种情况，综上只需要讨论我们列举的两种情况即可。

对于某个索引i，如果满足A[i] > A[i-1] && B[i] > B[i-1] 就认为在i位置时，是满足递增的要求的。

对于某个索引i，如果满足A[i] > B[i-1] && B[i] > A[i-1] 就认为需要进行交换才可以满足递增的要求。

在考虑时，每一次我们都只需要考虑当前位置是否可以和他的前面一个位置构成严格递增，针对每一个位置如此考虑最终我们会得到一个整个数组都是严格递增。

在考虑每一个位置时，需要计算当前位置进行交换使当前位置达到递增的代价和不交换达到递增的代价和不交换使当前位置达到递增的代价。

我们在某个位置上可能的序列有两种针对A[i] > A[i - 1] && B[i] > B[i - 1]这种序列在该位置i上不交换的使得两数组递增的代价为：dp[0][i] = Math.min(dp[0][i], dp[0][i-1])，因为保持就好不用动就已经满足了递增要求在该位置上交换使得数组递增的代价为dp[1][i] = Math.min(dp[1][i], dp[1][i-1] + 1)，那么需要一起动这样才能保持递增的要求。

对于i位置序列为A[i] > B[i-1] && B[i] > A[i-1]时如果该位置不交换，使得两数组递增的代价为（思路就是i不换，就让i-1换，换完自然就满足两数组都递增了）dp[0][i] = Math.min(dp[0][i], dp[1][i-1]);对于i位置交换，使得两数组递增的代价为（思路就是i换，那么i-1就不要动，换完就满足了两数组都递增）：dp[1][i] = Math.min(dp[1][i], dp[0][i-1] + 1)

我们可以看到对于每一个位置都有两种方法使其呈现递增，那么最终的结果就是两者中的最小值。

# Conclusion