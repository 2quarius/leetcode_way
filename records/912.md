# My Answer
## First Edition(time out)
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        return mergeSort(nums);
    }
    vector<int> mergeSort(vector<int>& array){
        vector<int> result;
        if(array.size()==1){
            return array;
        }
        int half = array.size()/2;
        vector<int> left(array.begin(),array.begin()+half);
        vector<int> right(array.begin()+half,array.end());
        left = mergeSort(left);
        right = mergeSort(right);
        while(left.size()>0&&right.size()>0){
            if(left[0]<right[0]){
                result.push_back(left[0]);
                left.erase(left.begin());
            }
            else{
                result.push_back(right[0]);
                right.erase(right.begin());
            }
        }
        if(left.size()>0){
            result.insert(result.end(),left.begin(),left.end());
        }
        else if(right.size()>0){
            result.insert(result.end(),right.begin(),right.end());
        }
        return result;
    }
};
```
ä¹‹å‰[148](./148.md)çš„ç­”æ¡ˆæ˜¯è¿­ä»£çš„å½’å¹¶æ’åºï¼Œè¿™æ¬¡æˆ‘ç”¨äº†é€’å½’å¼çš„å½’å¹¶æ’åºï¼Œç„¶è€Œè¿˜æ˜¯timeoutäº†ã€‚è¿™ä¸ªç‰ˆæœ¬æœ¬æ¥å°±æœ‰å¾ˆå¤šé—®é¢˜ï¼Œä¸€ä¸ªæ˜¯å‡½æ•°å€¼ä¼ é€’çš„é—®é¢˜ï¼Œå¦ä¸€ä¸ªæ˜¯å‘é‡erase()å’Œinsert()çš„è°ƒç”¨ã€‚ï¼ˆå…¶ä»–é—®é¢˜æ¬¢è¿æå‡ºï¼‰
## Final Edition
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        return nums;
    }
};
```
# Extension
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int n = nums.size();
        HeapSort(nums,n);
        return nums;
    }
    //æ’å…¥
    void InsertSort(vector<int>& nums,int n) {
        for(int i=0;i<n;i++) {
            int temp = nums[i];
            int j = i-1;
            while(j >= 0 && nums[j] >temp) {
                nums[j+1] = nums[j];
                j--;
            }
            nums[j+1] = temp;
        }
    }
    //æŠ˜åŠæ’å…¥
    void HInsertSort(vector<int>& nums,int n) {
        int i,j,low,high,mid;
        for( i=0;i<n;i++ ){
            int tmp = nums[i];
            low = 0;high = i-1;
            while(low<=high) {
                mid = low+(high-low)/2;
                if(nums[mid] > tmp){
                    high = mid - 1;
                }else{
                    low = mid + 1;
                }
            }
            for(j=i-1;j>=high+1;j--){
                nums[j+1] = nums[j];
            }
            nums[high+1] = tmp;
        }
    }
    //å¸Œå°”
    void ShellSort(vector<int>& nums,int n){
        for(int dk = n/2;dk>=1;dk=dk/2){
            for(int i=dk;i<n;++i) {
                if(nums[i]<nums[i-dk]){
                    int tmp = nums[i],j;
                    for(j = i-dk;j>=0&&tmp<nums[j];j-=dk){
                        nums[j+dk] = nums[j];
                    }
                    nums[j+dk]=tmp;
                }
            }
        }
    }
    //å†’æ³¡
    void BubbleSort(vector<int>& nums,int n){
        for(int i=0;i<n-1;i++) {
            bool flag = false;
            for(int j=n-1;j>i;j--) {
                if(nums[j-1]>nums[j]){
                    swap(nums[j-1],nums[j]);
                    flag = true;
                }
            }
            if(flag == false){
                return ;
            }
        }
    }
    //å¿«æ’
    void QuickSort(vector<int>& nums,int low,int high,int n){
        if(low<high){
            int pivotpos = partition(nums,low,high);
            QuickSort(nums,low,pivotpos-1,n);
            QuickSort(nums,pivotpos+1,high,n);
        }
    }
    int partition(vector<int>& nums,int low,int high){
        int pivot = nums[low];
        while(low<high) {
            while(low<high && nums[high]>=pivot)--high;
            nums[low] = nums[high];
            while(low<high && nums[low]<=pivot) ++low;
            nums[high] = nums[low];
        }
        nums[low] = pivot;
        return low;
            
    }
    //ç®€å•é€‰æ‹©
    void SelectSort(vector<int>& nums,int n) {
        for(int i=0;i<n-1;i++) {
            int min = i;
            for(int j=i+1;j<n;j++) {
                if(nums[j]<nums[min]) min = j;
                if(min!=i) swap(nums[i],nums[min]);
            }
        }
    }
    //å †æ’åº
    void adjust(vector<int> &nums, int len, int index)
    {
        int left = 2*index + 1; // indexçš„å·¦å­èŠ‚ç‚¹
        int right = 2*index + 2;// indexçš„å³å­èŠ‚ç‚¹
    
        int maxIdx = index;
        if(left<len && nums[left] > nums[maxIdx])     maxIdx = left;
        if(right<len && nums[right] > nums[maxIdx])     maxIdx = right;
    
        if(maxIdx != index)
        {
            swap(nums[maxIdx], nums[index]);
            adjust(nums, len, maxIdx);
        }
    
    }
 
    // å †æ’åº
    void HeapSort(vector<int> &nums, int size)
    {
        for(int i=size/2 - 1; i >= 0; i--)
        {
            adjust(nums, size, i);
        }
        for(int i = size - 1; i >= 1; i--)
        {
            swap(nums[0], nums[i]);        
            adjust(nums, i, 0);              
        }
    }
};
```
# Conclusion
|æ’åºç®—æ³•|æ—¶è€—(ms)|å†…å­˜æ¶ˆè€—(MB)|
|-------|---|-------|
|sort|108|12.5|
|å †æ’|168|12.5|
|æ’å…¥|è¶…æ—¶|-----|
|æŠ˜åŠæ’å…¥|è¶…æ—¶|-----|
|å¸Œå°”|136|12.4|
|å†’æ³¡|è¶…æ—¶|-----|
|å¿«æ’|136|12.7|
|é€‰æ‹©æ’åº|è§£ç­”é”™è¯¯|è§£ç­”é”™è¯¯|

æ ¹æ®leetcodeçš„ç»“æœï¼Œæ’å…¥ã€æŠ˜åŠæ’å…¥ã€å†’æ³¡è€—æ—¶è¾ƒé•¿
ï¼ˆåœ¨timeoutçš„è¾¹ç¼˜å¤§é¹å±•ç¿…ï¼‰ã€‚

æ—¶è€—ï¼š å¿«æ’ $\approx$ å¸Œå°” < å †æ’

å†…å­˜æ¶ˆè€—ï¼šå¸Œå°” < å †æ’ < å¿«æ’

å½“ç„¶sortè¿˜æ˜¯æœ€å¥½çš„ğŸ˜ã€‚
